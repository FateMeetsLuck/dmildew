/*
"Borrowed" from https://github.com/then/promise/blob/master/src/core.js
 */

let asap = setImmediate;

function noop() {}

// States:
//
// 0 - pending
// 1 - fulfilled with _value
// 2 - rejected with _value
// 3 - adopted the state of another promise, _value
//
// once the state is no longer pending (0) it is immutable

// All `_` prefixed properties will be reduced to `_{random number}`
// at build time to obfuscate them and discourage their use.
// We don't use symbols or Object.defineProperty to fully hide them
// because the performance isn't good enough.


// to avoid using try/catch inside critical functions, we
// extract them to here.
let LAST_ERROR = null;
let IS_ERROR = {};
function getThen(obj) {
    try {
        return obj.then;
    } catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
    }
}

function tryCallOne(fn, a) {
    try {
        return fn(a);
    } catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
    }
}
function tryCallTwo(fn, a, b) {
    try {
        fn(a, b);
    } catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
    }
}

function Promise(fn) {
    if (typeof this !== 'object') {
        throw 'Promises must be constructed via new';
    }
    if (typeof fn !== 'function') {
        throw 'Promise constructor\'s argument is not a function';
    }
    this._deferredState = 0;
    this._state = 0;
    this._value = null;
    this._deferreds = null;
    // this._action = fn;
    if (fn === noop) return;
    doResolve(fn, this);
}
Promise._onHandle = null;
Promise._onReject = null;
Promise._noop = noop;

Promise.all = function(promises) {
    let resolved = 0;
    let results = [];
    return new Promise((resolve, reject)=>{
        for(let promise of promises) {
            promise
                .then(result => {
                    results.push(result);
                    if(++resolved === promises.length) resolve(results);
                })
                .catch(e => { reject(e); });
        }
    });
};

Promise.prototype.done = function (onFulfilled, onRejected) {
    let self = arguments.length ? this.then.apply(this, arguments) : this;
    self.then(null, function (err) {
        setTimeout(function () {
            throw err;
        }, 0);
    });
};

Promise.prototype.catch = function(onRejected) {
    return this.then(null, onRejected);
};

Promise.prototype.finally = function (f) {
    return this.then(function (value) {
        return Promise.resolve(f()).then(function () {
            return value;
        });
    }, function (err) {
        return Promise.resolve(f()).then(function () {
            throw err;
        });
    });
};

Promise.prototype.then = function(onFulfilled, onRejected) {
    if (this.constructor !== Promise) {
        return safeThen(this, onFulfilled, onRejected);
    }
    let res = new Promise(noop);
    handle(this, new Handler(onFulfilled, onRejected, res));
    return res;
};

function safeThen(self, onFulfilled, onRejected) {
    return new self.constructor(function (resolve, reject) {
        let res = new Promise(noop);
        res.then(resolve, reject);
        handle(self, new Handler(onFulfilled, onRejected, res));
    });
}

function handle(self, deferred) {
    while (self._state === 3) {
        self = self._value;
    }
    if (Promise._onHandle) {
        Promise._onHandle(self);
    }
    if (self._state === 0) {
        if (self._deferredState === 0) {
            self._deferredState = 1;
            self._deferreds = deferred;
            return;
        }
        if (self._deferredState === 1) {
            self._deferredState = 2;
            self._deferreds = [self._deferreds, deferred];
            return;
        }
        self._deferreds.push(deferred);
        return;
    }
    handleResolved(self, deferred);
}

function handleResolved(self, deferred) {
    self._fiber = asap(function() {
        let cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
        if (cb === null) {
            if (self._state === 1) {
                resolve(deferred.promise, self._value);
            } else {
                reject(deferred.promise, self._value);
            }
            return;
        }
        let ret = tryCallOne(cb, self._value);
        if (ret === IS_ERROR) {
            reject(deferred.promise, LAST_ERROR);
        } else {
            resolve(deferred.promise, ret);
        }
    });
}
function resolve(self, newValue) {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self) {
        return reject(
            self,
            'A promise cannot be resolved with itself.'
        );
    }
    if (
        newValue &&
        (typeof newValue === 'object' || typeof newValue === 'function')
    ) {
        let then = getThen(newValue);
        if (then === IS_ERROR) {
            return reject(self, LAST_ERROR);
        }
        if (
            then === self.then &&
            newValue instanceof Promise
        ) {
            self._state = 3;
            self._value = newValue;
            finale(self);
            return;
        } else if (typeof then === 'function') {
            doResolve(then.bind(newValue), self);
            return;
        }
    }
    self._state = 1;
    self._value = newValue;
    finale(self);
}

function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    if (Promise._onReject) {
        Promise._onReject(self, newValue);
    }
    finale(self);
}
function finale(self) {
    if (self._deferredState === 1) {
        handle(self, self._deferreds);
        self._deferreds = null;
    }
    if (self._deferredState === 2) {
        for (let i = 0; i < self._deferreds.length; i++) {
            handle(self, self._deferreds[i]);
        }
        self._deferreds = null;
    }
}

function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, promise) {
    let done = false;
    let res = tryCallTwo(fn, 
        function (value) {
            if (done) return;
            done = true;
            resolve(promise, value);
        }, 
        function (reason) {
            if (done) return;
            done = true;
            reject(promise, reason);
    });
    if (!done && res === IS_ERROR) {
        done = true;
        reject(promise, LAST_ERROR);
    }
}

//=============================================================================


function calculate(num1, operator, num2) {
    return new Promise((resolve, reject)=>{
        if(operator === '+') {
            resolve(num1 + num2);
            // setTimeout(resolve, 0, num1 + num2);
        } else {
            reject("Only addition is supported");
        }
    });
}

function delayedCodePoints(s1) {
    return new Promise((resolve, reject)=>{
        if(typeof s1 === "string" && s1.length > 0) {
            let result = s1.split("").map(ch => ch.charCodeAt(0));
            // console.log("The array I'm gonna send is " + result);
            setTimeout(resolve, 0, result);
            // resolve(result);
            // setImmediate(resolve, result);
        } else {
            reject("Not a string");
        }
    });
}

calculate(5, "-", 10)
    .then(result => console.log("Result is " + result))
    .catch(err => console.error("Could not calculate -: " + err));

calculate(69, "+", 11)
    .then(result => console.log("Result is " + result))
    .catch(err => console.error("Could not calculate +: " + err));

calculate(69, "+", 420)
    .then(result => { throw "This calculation may be offensive"; })
    .catch(err => console.error("Could not calculate 69+420: " + err));

delayedCodePoints("foo")
    .then(result => console.log("Result of foo: " + result))
    .catch(err => console.error("Couldn't do foo: " + err));

function testPromiseAll() 
{
    Promise.all([calculate(10, "+", 5), calculate(21, "+", -11), calculate("foo", "+", "bar")])
        .then(result => console.log("The result of all these promises is " + result))
        .catch(err => console.error("Something went wrong with all these promises: " + err))
        .finally(()=> console.log("Finally always do this"));

    Promise.all([delayedCodePoints("foo bar"), calculate(9, "+", 9)])
        .then(result => console.log("The mixed result is " + result))
        .catch(err => "Something wrong with the mixed results: " + err);

    Promise.all([delayedCodePoints("foo"), delayedCodePoints("bc")])
        .then(result => console.log(result))
        .catch(err => "I got a problem with these results: " + err);
}

testPromiseAll();



