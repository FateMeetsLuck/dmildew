/* 
Modified from https://itnext.io/broken-promises-a-barely-working-implementation-of-js-promises-ed7f99071f54 as
an experiment. The setTimeout 0 trick allows "instant" resolution. This implementation lacks Promise.all
 */
function Promise(action) {
    this.status = 'pending';
    this.value = undefined;
    
    this.thenCallbacks = [];
    this.onCatch = undefined;
    this.onFinally = undefined;

    this.action = action;
    this.actionTimeout = setTimeout(action, 0, this.resolver.bind(this), this.rejector.bind(this));
}

/**
 * Heavily adapted from https://medium.com/@muralikv/implementing-promise-all-in-javascript-732076497946
 * Makes a single Promise out of an Array of Promises
 * @param {Array<Promise>} promises An Array of Promises
 * @returns {Promise} A single Promise.
 */
Promise.all = function(promises) {
    let results = new Array(promises.length);
    let completedPromises = 0;

    return new Promise((resolve, reject)=>{
        promises.forEach((promise, index) => {
            if(!(promise instanceof Promise))
                throw promise + " is not a Promise";
            promise
            .then(value => {
                results[index] = value;
                ++completedPromises;
                if(completedPromises === promises.length) {
                    resolve(results);
                }
            })
            .catch(function(err) {
                reject(err);
            });

            if(promise.status == 'resolved') {
                results[index] = promise.value;
                ++completedPromises;
            }
            else if(promise.status == 'rejected')
                reject(promise.value);
        });
        if(completedPromises === promises.length)
            resolve(results);
    });
};

Promise.prototype.then = function(callback) {
    this.thenCallbacks.push(callback);
    return this;
};

Promise.prototype.catch = function(callback) {
    this.onCatch = callback;
    return this;
};

Promise.prototype.finally = function(callback) {
    this.onFinally = callback;
};

/// must bind before use
Promise.prototype.resolver = function(value) {
    try {
        this.status = 'resolved';
        this.value = value;
        this.thenCallbacks.forEach(function(func) {
            func(this.value);
        }, this);
    } catch (err) {
        this.value = err;
        if(typeof this.onCatch === 'function')
            this.onCatch(err);
    } finally {
        if(typeof this.onFinally === 'function') {
            this.onFinally(this.value);
        }
    }
};

/// must bind before use
Promise.prototype.rejector = function(value) {
    this.status = 'rejected';
    this.value = value;

    if(typeof this.onCatch === 'function') {
        this.onCatch(this.value);
    }

    if(typeof this.onFinally === 'function') {
        this.onFinally(this.value);
    }
};

function calculate(num1, operator, num2) {
    return new Promise((resolve, reject)=>{
        if(operator === '+') {
            resolve(num1 + num2);
            // setTimeout(resolve, 0, num1 + num2);
        } else {
            reject("Only addition is supported");
        }
    });
}

function delayedCodePoints(s1) {
    return new Promise((resolve, reject)=>{
        if(typeof s1 === "string" && s1.length > 0) {
            let result = s1.split("").map(ch=>ch.codePointAt(0));
            setTimeout(resolve, 250, result);
        } else {
            reject("Not a string");
        }
    });
}

calculate(5, "-", 10)
    .then(result => console.log("Result is " + result))
    .catch(err => console.error("Could not calculate -: " + err));

calculate(69, "+", 11)
    .then(result => console.log("Result is " + result))
    .catch(err => console.error("Could not calculate +: " + err));

calculate(69, "+", 420)
    .then(result => { throw "This calculation may be offensive"; })
    .catch(err => console.error("Could not calculate 69+420: " + err));

function testPromiseAll() 
{
    Promise.all([calculate(10, "+", 5), calculate(21, "+", -11), calculate("foo", "+", "bar")])
        .then(result => console.log("The result of all these promises is " + result))
        .catch(err => console.error("Something went wrong with all these promises: " + err))
        .finally(()=> console.log("Finally always do this"));

    Promise.all([delayedCodePoints("foo bar"), calculate(9, "+", 9)])
        .then(result => console.log("The mixed result is " + result))
        .catch(err => "Something wrong with the mixed results: " + err);
}

testPromiseAll();

// By some miracle this works so far
